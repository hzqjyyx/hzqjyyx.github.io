<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="algorithm,notes,tree," />


<meta name="description" content="Basic Idea We represent each node of a tree by an object. As with linked lists, we assume that each node contains a key attribute. The remaining attributes of interest are pointers to other nodes, an">
<meta name="keywords" content="algorithm,notes,tree">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(03): Tree">
<meta property="og:url" content="https://hzqjyyx.github.io/2018/06/Algorithm-03-Tree/index.html">
<meta property="og:site_name" content="泽强的工作台">
<meta property="og:description" content="Basic Idea We represent each node of a tree by an object. As with linked lists, we assume that each node contains a key attribute. The remaining attributes of interest are pointers to other nodes, an">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://i.loli.net/2018/11/29/5bfed9d4c2453.png">
<meta property="og:image" content="https://i.loli.net/2018/11/29/5bfeda45ce738.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/N-ary_to_binary.svg/500px-N-ary_to_binary.svg.png">
<meta property="og:image" content="https://i.loli.net/2018/11/29/5bfedc3f075af.png">
<meta property="og:image" content="https://i.loli.net/2018/11/29/5bfee6c969321.png">
<meta property="og:image" content="https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png">
<meta property="og:image" content="https://i.loli.net/2018/12/28/5c2564fab25a7.png">
<meta property="og:image" content="https://i.loli.net/2018/12/28/5c2564c95521c.png">
<meta property="og:image" content="https://i.loli.net/2018/12/28/5c2528a225645.png">
<meta property="og:image" content="https://i.loli.net/2018/12/02/5c02db4b6044f.png">
<meta property="og:image" content="https://i.loli.net/2018/12/02/5c02db20e01c9.png">
<meta property="og:image" content="https://i.loli.net/2018/12/01/5c018ea9706fd.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/31/Tree_rotation_animation_250x250.gif">
<meta property="og:image" content="https://i.loli.net/2018/12/02/5c035bbb0388d.png">
<meta property="og:image" content="https://i.loli.net/2018/12/02/5c035ff5c1084.png">
<meta property="og:image" content="https://i.loli.net/2018/12/04/5c05a8ecd52df.png">
<meta property="og:updated_time" content="2019-01-01T19:27:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm(03): Tree">
<meta name="twitter:description" content="Basic Idea We represent each node of a tree by an object. As with linked lists, we assume that each node contains a key attribute. The remaining attributes of interest are pointers to other nodes, an">
<meta name="twitter:image" content="https://i.loli.net/2018/11/29/5bfed9d4c2453.png">






  <link rel="canonical" href="https://hzqjyyx.github.io/2018/06/Algorithm-03-Tree/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Algorithm(03): Tree | 泽强的工作台</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泽强的工作台</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记/科研</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            Archives</a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            Search</a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzqjyyx.github.io/2018/06/Algorithm-03-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄泽强（Zeqiang Huang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泽强的工作台">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Algorithm(03): Tree</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-13T18:57:13-07:00">2018-06-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/book/" itemprop="url" rel="index"><span itemprop="name">book</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/Algorithm-03-Tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/Algorithm-03-Tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Symbols count in article&#58;</span>
                
                <span title="Symbols count in article"></span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="basic-idea"><a class="markdownIt-Anchor" href="#basic-idea"></a> Basic Idea</h1>
<p>We represent each node of a tree by an object. As with linked lists, we assume that each node contains a <strong>key</strong> attribute. The remaining attributes of interest are pointers to other nodes, and they vary according to the type of tree.</p>
<ul>
<li>free tree</li>
<li>binary tree</li>
<li>binary search tree</li>
<li>segment tree</li>
<li>interval tree</li>
<li>trie</li>
<li>red-black tree</li>
<li>B-Tree/B+Tree</li>
<li>skip list (TODO)</li>
<li>AVL tree (TODO)</li>
<li>union find</li>
</ul>
<a id="more"></a>
<h1 id="concepts"><a class="markdownIt-Anchor" href="#concepts"></a> Concepts</h1>
<h2 id="free-tree"><a class="markdownIt-Anchor" href="#free-tree"></a> Free Tree</h2>
<p><strong>free tree</strong>: a connected, acyclic, undirected graph.<br>
<strong>forest</strong>: If an undirected graph is acyclic but possibly disconnected, it is a <strong>forest</strong>.<br>
<img src="https://i.loli.net/2018/11/29/5bfed9d4c2453.png" alt="">ageslim)</p>
<p><strong>Properties of free trees</strong>: Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> be an <strong>undirected graph</strong>. The following statements are equivalent.</p>
<ol>
<li>G is a free tree.</li>
<li>Any two vertices in G are connected by a unique simple path.</li>
<li>G is connected, but if any edge is removed from E, the resulting graph is disconnected.</li>
<li>G is connected, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|E|=|V|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span>.</li>
<li>G is acyclic, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|E|=|V|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span>.</li>
<li>G is acyclic, but if any edge is added to E, the resulting graph contains a <strong>cycle</strong>.</li>
</ol>
<h2 id="rooted-and-ordered-tree"><a class="markdownIt-Anchor" href="#rooted-and-ordered-tree"></a> Rooted and ordered tree</h2>
<p><strong>rooted tree</strong>: a free tree in which one of the <strong>vertices</strong> is distinguished from the others.<br>
<strong>root</strong>: the distinguished vertex</p>
<p>Consider a node x in a rooted tree T with root r<br>
<strong>ancestor &amp; descendant</strong>: Any node <strong>y</strong> on the unique simple path from r to x is an <strong>ancestor</strong> of <strong>x</strong>. Then <strong>x</strong> is <strong>descendant</strong> of <strong>y</strong>.<br>
<strong>subtree rooted at x</strong>: The tree induced by descendants of x, rooted at x.<br>
<strong>parent and child</strong>: If the last edge on the simple path from the root r of a tree T to a node x is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(y,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>, then <strong>y</strong> is <strong>parent</strong> of <strong>x</strong>, and <strong>x</strong> is child of <strong>y</strong>.<br>
<strong>sibling</strong>: If two node have the same parent, they are <strong>siblings</strong>.<br>
<strong>leaf/external node &amp; internal node</strong>: A node with no children is a <strong>leaf or external node</strong>. A nonleaf node is an <strong>internal</strong> node.<br>
<strong>degree</strong>: The number of <strong>children</strong> of a node x.<br>
<strong>level</strong>: All nodes at the same depth.<br>
<strong>height</strong>:  The number of edges on the longest simple downward path from the node to a leaf.<br>
<strong>depth</strong>: The length of the simple path from the root r to a node x<br>
<strong>ordered tree</strong>:  a rooted tree in which the children of each node are <strong>ordered</strong>. That is, if a node has k children, then there is a ﬁrst child, a second child, …, and a kth child</p>
<p><img src="https://i.loli.net/2018/11/29/5bfeda45ce738.png" alt=""></p>
<h1 id="binary-tree"><a class="markdownIt-Anchor" href="#binary-tree"></a> Binary Tree</h1>
<p>A binary tree is a structure on finite set of nodes that</p>
<ul>
<li>contains no nodes, or</li>
<li>is composed of three disjoint sets of nodes: a root node, a left tree(binary tree), a right tree(binary tree).</li>
</ul>
<p>A binary tree is NOT simply an ordered tree in which each node has degree at most 2. The position of the child—whether it is the left child or the right child—matters. In an ordered tree, there is no distinguishing a sole child as being either left or right.</p>
<p><strong>full binary tree</strong>: each node is ether node or degree 2.<br>
<strong>complete binary tree</strong>: every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>
<p>For each node, the tree node can be represented as:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="left-child-right-sibling"><a class="markdownIt-Anchor" href="#left-child-right-sibling"></a> Left-child right-sibling</h2>
<p>We can easily extend the schema for representing a binary tree to any class of trees in which the number of children of each node is at most some constant k. But this schema no longer works when the number of children of a node is unbounded.<br>
We use <strong>left-child, right-sibling representation</strong>, which only uses <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> space. As before, each node contains a parent pointer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T.root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">t</span></span></span></span> points to the root of tree <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span>. Instead of having a pointer to each of its children, however, each node x has only two pointers:</p>
<ul>
<li><code>x.left-child</code> points to the left most child</li>
<li><code>x.right-sibling</code> points to the sibling of x immediately to its right.</li>
</ul>
<p>If node x has no children, then <code>x.left-child = NIL</code>, and if node x is the rightmost child of its parent, then <code>x.right-sibling = NIL</code>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/N-ary_to_binary.svg/500px-N-ary_to_binary.svg.png" alt="mark"></p>
<h1 id="traversal"><a class="markdownIt-Anchor" href="#traversal"></a> Traversal</h1>
<p><strong>inorder tree walk</strong>: print root between left child and right child.<br>
<strong>preorder tree walk</strong>: print root, then left child and right child.<br>
<strong>postorder tree walk</strong>: print left child and right child, then print root.</p>
<h2 id="recursively"><a class="markdownIt-Anchor" href="#recursively"></a> Recursively</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">  if x != NIL</span><br><span class="line">    INORDER-TREE-WALK(x.left)</span><br><span class="line">    print x.key</span><br><span class="line">    INORDER-TREE-WALK(x.right)</span><br><span class="line">    </span><br><span class="line">PREORDER-TREE-WALK(x)</span><br><span class="line">  if x != NIL</span><br><span class="line">  	print x.key</span><br><span class="line">    PREORDER-TREE-WALK(x.left)</span><br><span class="line">    PREORDER-TREE-WALK(x.right)</span><br><span class="line">  </span><br><span class="line">POSTORDER-TREE-WALK(x)</span><br><span class="line">  if x != NIL</span><br><span class="line">    POSTORDER-TREE-WALK(x.left)</span><br><span class="line">    POSTORDER-TREE-WALK(x.right)</span><br><span class="line">    print x.key</span><br></pre></td></tr></table></figure>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> times and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> space (function stack).</p>
<h2 id="iterative"><a class="markdownIt-Anchor" href="#iterative"></a> Iterative</h2>
<h3 id="pre-order-traversal"><a class="markdownIt-Anchor" href="#pre-order-traversal"></a> Pre-order Traversal</h3>
<ol>
<li>Create an empty stack and push root node to stack.</li>
<li>Do following while nodeStack is not empty.
<ol>
<li>Pop an item from stack and print it.</li>
<li>Push <strong>right</strong> child of popped item to stack</li>
<li>Push <strong>left</strong> child of popped item to stack</li>
</ol>
</li>
</ol>
<p><u>Right child is pushed before left child to make sure that left subtree is processed first.</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An iterative process to print preorder traversal of Binary tree </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterativePreorder</span><span class="params">(Node node)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Create an empty stack and push root to it </span></span><br><span class="line">    Stack&lt;Node&gt; nodeStack = <span class="keyword">new</span> Stack&lt;Node&gt;(); </span><br><span class="line">    nodeStack.push(root); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123; </span><br><span class="line">        <span class="comment">// Pop the top item from stack and print it </span></span><br><span class="line">        Node mynode = nodeStack.pop(); </span><br><span class="line">        visit(mynode.data); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push right and left children of the popped node to stack </span></span><br><span class="line">        <span class="keyword">if</span> (mynode.right != <span class="keyword">null</span>)  nodeStack.push(mynode.right); </span><br><span class="line">        <span class="keyword">if</span> (mynode.left != <span class="keyword">null</span>)  nodeStack.push(mynode.left); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in-order-traversal"><a class="markdownIt-Anchor" href="#in-order-traversal"></a> In-order Traversal</h3>
<p>Stack stores path from root down to current node (exclusive).</p>
<ol>
<li>Create an empty stack S.</li>
<li>Initialize current node as root</li>
<li>Push the current node to S and set current = current-&gt;left until current is NULL (find leftmost children of current node)</li>
<li>Pop the top item from stack. (leftmost node)</li>
<li>Print the popped item, set current = popped_item-&gt;right</li>
<li>If current is not NULL or stack is not empty then Go to step 3.</li>
<li>If current is NULL and stack is empty then we are done.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;Node&gt;(); </span><br><span class="line">    Node curr = root; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || s.size() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* Reach the left most Node of the curr Node */</span></span><br><span class="line">        <span class="keyword">while</span> (curr !=  <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">/* place pointer to a tree node on the stack before traversing the node's left subtree */</span></span><br><span class="line">            s.push(curr); </span><br><span class="line">            curr = curr.left; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Current must be NULL at this point */</span></span><br><span class="line">        curr = s.pop(); </span><br><span class="line">        visit(curr.data); </span><br><span class="line">        <span class="comment">/* we have visited the node and its left subtree.  Now, it's right subtree's turn */</span></span><br><span class="line">        curr = curr.right; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="post-order-traversal"><a class="markdownIt-Anchor" href="#post-order-traversal"></a> Post-order Traversal</h3>
<p>We can call it Reversed Pre-order</p>
<p>Observe that post-order is reverse of pre-order which the only difference is right node visited before left node.<br>
So we can store pre-order (right node first) result in the second stack and print it after we traversal the tree.</p>
<ol>
<li>Push root to first stack.</li>
<li>Loop while first stack is not empty<br>
2.1 Pop a node from first stack and push it to second stack<br>
2.2 Push left and right children of the popped node to first stack</li>
<li>Print contents of second stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderIterative</span><span class="params">(node root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// Create two stacks </span></span><br><span class="line">    Stack s1 = <span class="keyword">new</span> Stack&lt;&gt;(), s2 = <span class="keyword">new</span> Stack&lt;&gt;(); </span><br><span class="line">    s1.push(root); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty()) &#123; </span><br><span class="line">        <span class="comment">// Pop an item from s1 and push it to s2 </span></span><br><span class="line">        node temp = s1.pop(); </span><br><span class="line">        s2.push(temp); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push left and right children of </span></span><br><span class="line">        <span class="comment">// removed item to s1 </span></span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) s1.push(temp.left); </span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) s1.push(temp.right); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print all elements of second stack </span></span><br><span class="line">    <span class="keyword">while</span> (!s2.isEmpty()) &#123; </span><br><span class="line">        node temp = s2.pop(); </span><br><span class="line">        System.out.print(temp.data + <span class="string">" "</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="binary-search-tree"><a class="markdownIt-Anchor" href="#binary-search-tree"></a> Binary Search Tree</h1>
<h2 id="explanation"><a class="markdownIt-Anchor" href="#explanation"></a> Explanation</h2>
<p>The keys in binary search tree are always stored to satisfied <strong>binary-search-tree-property</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>≤</mo><mi>x</mi><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x.left.key \leq x.key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> &amp; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>≥</mo><mi>x</mi><mi mathvariant="normal">.</mi><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x.right.key \geq x.key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>. For a certain list of keys,  different binary search trees can represent the same set of values.</p>
<p><img src="https://i.loli.net/2018/11/29/5bfedc3f075af.png" alt=""></p>
<h2 id="suitable-situation"><a class="markdownIt-Anchor" href="#suitable-situation"></a> Suitable Situation</h2>
<p>Binary Search Tree allows fast lookup, addition and removal, at most <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is maximum height. It is much better than linear time. However, in worst case, BST may be unbalanced, so <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">h=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">h</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">n</span></span></span></span>. In practice, we use advanced tree structure, like Red-Black Tree, AVL Tree to avoid this situation.</p>
<h2 id="query"><a class="markdownIt-Anchor" href="#query"></a> Query</h2>
<h3 id="search"><a class="markdownIt-Anchor" href="#search"></a> Search</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// recursive</span><br><span class="line">TREE-SEARCH(x, k)</span><br><span class="line">  if x == NIL or k == x.key</span><br><span class="line">    return x</span><br><span class="line">  if x.key &lt; k</span><br><span class="line">    return TREE-SEARCH(x.right, k)</span><br><span class="line">  else return TREE-SEARCH(x.left, k)</span><br><span class="line"></span><br><span class="line">// iterative</span><br><span class="line">TREE-SEARCH(x, k)</span><br><span class="line">  while x != NIL and x.key != k</span><br><span class="line">    if x.key &lt; k</span><br><span class="line">      x = x.right</span><br><span class="line">    else x = x.left</span><br></pre></td></tr></table></figure>
<p>If k is smaller than x.key, the search continues in the left subtree of x, since the binary-search tree property implies that k could not be stored in the right subtree. Symmetrically, if k is larger than x.key, the search continues in the right subtree.</p>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is the height of the tree.</p>
<h3 id="minimum-and-maximum"><a class="markdownIt-Anchor" href="#minimum-and-maximum"></a> Minimum and Maximum</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINIMUM(x)</span><br><span class="line">  while x.left != NIL</span><br><span class="line">    x = x.left</span><br><span class="line">  return x</span><br><span class="line"></span><br><span class="line">MAXIMUM(x)</span><br><span class="line">  while x.right != NIL</span><br><span class="line">    x = x.right</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is the height of the tree.</p>
<h3 id="successor-and-predecessor"><a class="markdownIt-Anchor" href="#successor-and-predecessor"></a> Successor and Predecessor</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// assume p existed in T</span><br><span class="line">SUCCESSOR(T, p)</span><br><span class="line">  n = T.root</span><br><span class="line">  y = NIL</span><br><span class="line">  while n != NIL</span><br><span class="line">    if n.val &gt; p.val</span><br><span class="line">      y = n</span><br><span class="line">      n = n.left // always find nodes less than current node</span><br><span class="line">    else n = n.right</span><br><span class="line">  return y</span><br><span class="line"></span><br><span class="line">PREDECESSOR(T, p)</span><br><span class="line">  n = T.root</span><br><span class="line">  y = NIL</span><br><span class="line">  while n != NIL</span><br><span class="line">    if n.val &lt; p.val</span><br><span class="line">      y = n</span><br><span class="line">      n = n.right</span><br><span class="line">    else n = n.left</span><br><span class="line">  return y</span><br></pre></td></tr></table></figure>
<p>The idea is to compare <code>root</code>'s value with <code>p</code>'s value if <code>root</code> is not null, and consider the following two cases:</p>
<ul>
<li><code>root.val &gt; p.val</code>. In this case, <code>root</code> can be a possible answer, so we store the root node first and call it <code>y</code>. However, we don’t know if there is anymore node on <code>root</code>'s left that is larger than <code>p.val</code>. So we move root to its left and check again.</li>
<li><code>root.val &lt;= p.val</code>. In this case, <code>root</code> cannot be <code>p</code>'s inorder successor, neither can <code>root</code>'s left child. So we only need to consider <code>root</code>'s right child, thus we move root to its right and check again.</li>
</ul>
<p>We continuously move <code>root</code> until exhausted. To this point, we only need to return the <code>y</code> in case 1.</p>
<p>Inorder Successor of an input node can also be defined as the node with the smallest key greater than the key of input node.</p>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is the height of the tree.</p>
<h2 id="insert-and-delete"><a class="markdownIt-Anchor" href="#insert-and-delete"></a> Insert and Delete</h2>
<p>Modifying the tree to insert a new element is relatively straightforward, but handling deletion is somewhat more intricate</p>
<h3 id="insert"><a class="markdownIt-Anchor" href="#insert"></a> Insert</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// z is a node, z.p, z.left, z.right are NIL</span><br><span class="line">TREE-INSERT(T, z)</span><br><span class="line">  y = NIL // y is the node that z is being to be appended.</span><br><span class="line">  x = T.root</span><br><span class="line">  while x != NIL</span><br><span class="line">    y = x</span><br><span class="line">    if z.key &lt; x.key</span><br><span class="line">      x = x.left</span><br><span class="line">    else x = x.right</span><br><span class="line">  if y==NIL</span><br><span class="line">    T.root = z</span><br><span class="line">  else if z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">  else y.right = z</span><br></pre></td></tr></table></figure>
<p>The procedure maintains the <strong>trailing pointer</strong> y as the parent of x. After initialization, the while loop in lines 3–7 causes these two pointers to move down the tree, going left or right depending on the comparison of z.key with x.key, until x becomes NIL. The NIL occupies the position where we wish to place the input item z.</p>
<p>We need the trailing pointer y, because by the time we ﬁnd the NIL where z belongs, the search has proceeded one step beyond the node that needs to be changed.</p>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is the height of the tree.</p>
<h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> Delete</h3>
<p>There are 3 different cases when deleting a node z: z has no child, z has one child or z has two children.</p>
<ul>
<li>If z has no left child, then we replace z by its right child, which may or may not be NIL.</li>
<li>If z has just one child, which is its left child, then we replace z by its left child.</li>
<li>Otherwise, z has both a left and a right child. We ﬁnd z’s successor y, which lies in z’s right subtree and <strong>has no left child</strong>. We want to splice y out of its current location and have it replace z in the tree.
<ul>
<li>If y is z’s right child, then we replace z by y, leaving y’s right child alone.</li>
<li>Otherwise, y lies within z’s right subtree but is not z’s right child. In this case, we ﬁrst replace y by its own right child, let y be the root of r, and then we replace z by y.</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2018/11/29/5bfee6c969321.png" alt=""></p>
<p>It takes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span> time, h is the height of the tree.</p>
<h2 id="random-build-binary-search-tree"><a class="markdownIt-Anchor" href="#random-build-binary-search-tree"></a> Random Build Binary Search Tree</h2>
<p>The height of a binary search tree varies as items are inserted and deleted.  If, for example, the n items are inserted in strictly increasing order, the tree will be a chain with height <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span>. Unfortunately, little is known about the average height of a binary search tree when both insertion and deletion are used to create it. Let us therefore deﬁne a randomly built binary search tree on n keys as one that arises from inserting the keys in random order into an initially empty tree,where each of the n permutations of the input keys is equally likely. It gives us the ability have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> height tree in average case.</p>
<h2 id="java-code"><a class="markdownIt-Anchor" href="#java-code"></a> Java Code</h2>
<script src="https://gist.github.com/hzqjyyx/6456c6736b9578d877263e130c2a0532.js"></script>
<h2 id="non-distinct-keys"><a class="markdownIt-Anchor" href="#non-distinct-keys"></a> Non-distinct keys</h2>
<p><a href="https://www.geeksforgeeks.org/how-to-handle-duplicates-in-binary-search-tree/" target="_blank" rel="noopener">Beautiful Link</a></p>
<p>How to allow duplicates where every insertion inserts one more key with a value and every deletion deletes one occurrence?</p>
<p>A <strong>Simple Solution</strong> is to allow same keys on right side (we could also choose left side). For example consider insertion of keys 12, 10, 20, 9, 11, 10, 12, 12 in an empty Binary Search Tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      12</span><br><span class="line">    /    \</span><br><span class="line">  10     20</span><br><span class="line"> /  \    /</span><br><span class="line">9   11  12 </span><br><span class="line">   /     \</span><br><span class="line"> 10      12</span><br></pre></td></tr></table></figure>
<p>A <strong>Better Solution</strong> is to augment every tree node to store count together with regular fields like key, left and right pointers.<br>
Insertion of keys 12, 10, 20, 9, 11, 10, 12, 12 in an empty Binary Search Tree would create following.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         12(3)</span><br><span class="line">       /       \</span><br><span class="line">     10(2)     20(1)</span><br><span class="line">    /    \       </span><br><span class="line"> 9(1)   11(1)   </span><br><span class="line"></span><br><span class="line">Count of a key is shown in bracket</span><br></pre></td></tr></table></figure>
<p>This approach has following advantages over above simple approach.</p>
<ol>
<li>
<p>Height of tree is small irrespective of number of duplicates. Note that most of the BST operations (search, insert and delete) have time complexity as O(h) where h is height of BST. So if we are able to keep the height small, we get advantage of less number of key comparisons.</p>
</li>
<li>
<p>Search, Insert and Delete become easier to do. We can use same insert, search and delete algorithms with small modifications (see below code).</p>
</li>
<li>
<p>This approach is suited for self-balancing BSTs (<a href="https://www.geeksforgeeks.org/archives/17679" target="_blank" rel="noopener">AVL Tree</a>, <a href="https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank" rel="noopener">Red-Black Tree</a>, etc) also. These trees involve rotations, and a rotation may violate BST property of simple solution as a same key can be in either left side or right side after rotation.</p>
</li>
</ol>
<h1 id="segment-tree"><a class="markdownIt-Anchor" href="#segment-tree"></a> Segment Tree</h1>
<p>Segment tree is a very flexible data structure, because it is used to solve numerous range query problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.</p>
<p><img src="https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png" alt="307_RSQ_SegmentTree.png"></p>
<p>With segment tree, preprocessing time is O(n) and time to for range query is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. The extra space required is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> to store the segment tree.</p>
<p>Representation of Segment trees</p>
<ol>
<li>Leaf Nodes are the elements of the input array.</li>
<li>Each internal node represents range information of all leaves under it.</li>
</ol>
<p>Just like heap, we can use an length of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">2</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">n</span></span></span></span> array to store the tree structure. Let’s say the current node’s index is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span>, the left child is at <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2*i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord">2</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">i</span></span></span></span>, the right child is at <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2*i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord">2</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span>, the parent is at <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>i</mi><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">⌊</span><span class="mord mathit">i</span><span class="mclose">⌋</span></span></span></span>. array starts from 1</p>
<p>The segment tree for array <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[0, 1, \ldots ,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> is a binary tree in which each node contains <strong>aggregate</strong> information (min, max, sum, etc.) for a subrange <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>…</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i \ldots j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">[</span><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> of the array, as its left and right child hold information for range <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>…</mo><mfrac><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>]</mo></mrow><annotation encoding="application/x-tex">[i \ldots \frac{i+j}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.907772em;"></span><span class="strut bottom" style="height:1.252772em;vertical-align:-0.345em;"></span><span class="base"><span class="mopen">[</span><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.907772em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewbox="0 0 400000 200" preserveaspectratio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"/></svg></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mfrac><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[\frac{i + j}{2} + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.907772em;"></span><span class="strut bottom" style="height:1.252772em;vertical-align:-0.345em;"></span><span class="base"><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.907772em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewbox="0 0 400000 200" preserveaspectratio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"/></svg></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>.</p>
<h2 id="recursive"><a class="markdownIt-Anchor" href="#recursive"></a> Recursive</h2>
<p><img src="https://i.loli.net/2018/12/28/5c2564fab25a7.png" alt=""></p>
<h3 id="build-segment-tree"><a class="markdownIt-Anchor" href="#build-segment-tree"></a> Build Segment Tree</h3>
<p>Remember, it is not a complete tree. So maximum size is the size of a complete full binary tree.<br>
In order to build segment tree on current node, we need to build left subtree, right subtree, and sum its up.</p>
<p>Complexity is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeSumRecursive</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> maximumSize = <span class="number">2</span> * (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, Math.ceil(Math.log(n) / Math.log(<span class="number">2</span>))) - <span class="number">1</span>;</span><br><span class="line">    tree = <span class="keyword">new</span> <span class="keyword">int</span>[maximumSize];</span><br><span class="line">    buildTree(arr, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        tree[node] = arr[left];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = getMiddle(left, right);</span><br><span class="line">        buildTree(arr, left, mid, <span class="number">2</span> * node);</span><br><span class="line">        buildTree(arr, mid + <span class="number">1</span>, right, <span class="number">2</span> * node + <span class="number">1</span>);</span><br><span class="line">        tree[node] = tree[<span class="number">2</span> * node] + tree[<span class="number">2</span> * node + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h3>
<p>To update an element, look at the interval in which the element is present and recurse accordingly on the left or the right child.</p>
<p>Complexity of update will be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, idx, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = getMiddle(left, right);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt;= mid &amp;&amp; left &lt;= idx) &#123;</span><br><span class="line">            update(node * <span class="number">2</span>, left, mid, idx, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right, idx, val);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="query-2"><a class="markdownIt-Anchor" href="#query-2"></a> Query</h3>
<p>To query on a given range, check 3 conditions.</p>
<ol>
<li>Range represented by a node is completely inside the given range</li>
<li>Range represented by a node is completely outside the given range</li>
<li>Range represented by a node is partially inside and partially outside the given range</li>
</ol>
<p>If the range represented by a node is completely outside the given range, simply return 0.<br>
If the range represented by a node is completely within the given range, return the value of the node which is the sum of all the elements in the range represented by the node.<br>
And if the range represented by a node is partially inside and partially outside the given range, return sum of the left child and the right child.</p>
<p>Complexity of query will be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(left, right, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> qLeft, <span class="keyword">int</span> qRight, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; qLeft || left &gt; qRight) &#123;</span><br><span class="line">        <span class="comment">// out of boundary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= qLeft &amp;&amp; right &lt;= qRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = getMiddle(left, right);</span><br><span class="line">        <span class="keyword">return</span> query(qLeft, qRight, left, mid, node * <span class="number">2</span>) +</span><br><span class="line">            query(qLeft, qRight, mid + <span class="number">1</span>, right, node * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iterative-2"><a class="markdownIt-Anchor" href="#iterative-2"></a> Iterative</h2>
<p>It is more concise, faster, but not easy to be understand.<br>
The basic graph is shown below:</p>
<p><img src="https://i.loli.net/2018/12/28/5c2564c95521c.png" alt=""></p>
<h3 id="build-segment-tree-2"><a class="markdownIt-Anchor" href="#build-segment-tree-2"></a> Build Segment Tree</h3>
<p>Build process is from bottom to up. For every leaf node (2n-1 to n), which is the elements in original array, simply store it in tree array. For each step from n-1 to 0, we merge the infos of left child and right child. Merge can be min, max, sum, etc.</p>
<p>e.g. If we want to calculate <strong>sum</strong>, we begin from the leaves, initialize them with input array elements <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[0, 1, \ldots, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>. Then we move upward to the higher level to calculate the parents’ sum till we get to the root of the segment tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] tree;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n * <span class="number">2</span>];</span><br><span class="line">        buildTree(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>;  i &lt; <span class="number">2</span> * n; i++,  j++)</span><br><span class="line">        tree[i] = nums[j];</span><br><span class="line">    <span class="comment">// tree[0] is not used</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Single value (occurs when array’s length is odd) which cannot be paired will be prompted to upper level.</p>
<h3 id="update-2"><a class="markdownIt-Anchor" href="#update-2"></a> Update</h3>
<p>We update the leaf node that stores <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span>. From there we will follow the path up to the root updating the value of each parent as a sum of its children values.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tree started from 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    pos += n;</span><br><span class="line">    tree[pos] = val;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = pos;</span><br><span class="line">        <span class="keyword">int</span> right = pos;</span><br><span class="line">        <span class="keyword">if</span> (pos % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// pos is a left child</span></span><br><span class="line">            right = pos + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// pos is a right child</span></span><br><span class="line">            left = pos - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent is updated after child is updated</span></span><br><span class="line">        tree[pos / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">        pos /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It requires <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> time.</p>
<p>At first I got confused by <code>pos % 2 == 0</code>. Finally I got it. Remember it is a complete binary tree and it starts from 1. The index of left node is always even number, because it is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">2</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">n</span></span></span></span>, and right is at odd number.</p>
<h3 id="query-3"><a class="markdownIt-Anchor" href="#query-3"></a> Query</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get leaf with value 'l'</span></span><br><span class="line">    l += n;</span><br><span class="line">    <span class="comment">// get leaf with value 'r'</span></span><br><span class="line">    r += n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((l % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// l is right child, r is larger than l</span></span><br><span class="line">           <span class="comment">// so, tree[l] should appear in final result</span></span><br><span class="line">           sum += tree[l];</span><br><span class="line">           <span class="comment">// move l to siblings, because this part is already handled.</span></span><br><span class="line">           l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           sum += tree[r];</span><br><span class="line">           r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">        r /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For left pointer:</p>
<ul>
<li>If it points to a left child of parent node x, it means the left and right children should be both added to result. So we can add value of x directly. So we ignore it for now and move the pointer to parent x.</li>
<li>If it points to a right child of parent node x, it means the range has overlap with x, but not included. So we can only add tree[l]. And this part is processed, move left pointer to right siblings. Because the unhandled range only happens in that part.</li>
</ul>
<h1 id="binary-indexed-tree"><a class="markdownIt-Anchor" href="#binary-indexed-tree"></a> Binary Indexed Tree</h1>
<blockquote>
<p>Beautiful Video <a href="https://www.youtube.com/watch?v=CWDQJGaN1gY" target="_blank" rel="noopener">Link</a></p>
</blockquote>
<p>It is also called Fenwick Tree. It can support <strong>prefix query</strong> and <strong>update</strong> in both <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> time. Compared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.</p>
<p>Binary Indexed Tree is represented as an array. Let the array be <code>BITree[]</code>. Each node of the Binary Indexed Tree stores the <strong>sum of some elements</strong> of the input array. The size of the Binary Indexed Tree is equal to the size of the input array, denoted as <strong>n</strong>. In the code below, we use a size of n+1 for ease of implementation.</p>
<p><code>BITree[0]</code> is a dummy node.<br>
<code>BITree[y]</code> is the parent of <code>BITree[x]</code>, if and only if y can be obtained by removing the last set bit from the binary representation of x, that is <code>y = x – (x &amp; (-x))</code>.<br>
The child node <code>BITree[x]</code> of the node <code>BITree[y]</code> stores the sum of the elements between y(inclusive) and x(exclusive): <code>arr[y,…,x)</code>.</p>
<h2 id="query-4"><a class="markdownIt-Anchor" href="#query-4"></a> Query</h2>
<p><img src="https://i.loli.net/2018/12/28/5c2528a225645.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getSum(x): Returns the sum of the sub-array arr[0,...,x]</span><br><span class="line">// Returns the sum of the sub-array arr[0,...,x] using BITree[0..n], which is constructed from arr[0..n-1]</span><br><span class="line">1) Initialize the output sum as 0, the current index as x+1.</span><br><span class="line">2) Do following while the current index is greater than 0.</span><br><span class="line">...a) Add BITree[index] to sum</span><br><span class="line">...b) index = index - (index &amp; (-index))</span><br><span class="line">3) Return sum.</span><br></pre></td></tr></table></figure>
<h2 id="update-3"><a class="markdownIt-Anchor" href="#update-3"></a> Update</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update(x, val): Updates the Binary Indexed Tree (BIT) by performing arr[index] += val</span><br><span class="line">// Note that the update(x, val) operation will not change arr[].  It only makes changes to BITree[]</span><br><span class="line">1) Initialize the current index as x+1.</span><br><span class="line">2) Do the following while the current index is smaller than or equal to n.</span><br><span class="line">...a) Add the val to BITree[index]</span><br><span class="line">...b) index = index + (index &amp; (-index))</span><br></pre></td></tr></table></figure>
<h1 id="trie"><a class="markdownIt-Anchor" href="#trie"></a> Trie</h1>
<p>trie的好处在于能够方便的插入新的数据，且相比于btree-style来讲comparison的代价也更小，毕竟每次只要compare一个byte就完了。而相比于insert，trie的性能也可能很有可能更高，这是因为trie更加cache-friendly。对于这种memory bound的问题中合理利用cache是非常重要的。</p>
<p>Trie is a kind of search tree. <strong>All the descendants of a node have a common prefix of the string associated with that node</strong>, and the root is associated with the empty string.</p>
<p>If we store keys in binary search tree, a well balanced BST will need time proportional to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">M * log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>, where M is maximum string length and N is number of keys in tree. Using Trie, we can search the key in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> time. However the penalty is on Trie storage requirements.</p>
<p>Every node of Trie consists of multiple branches. Each branch represents a possible character of keys. We need to mark the last node of every key as end of word node. A Trie node field <code>isEndOfWord</code> is used to distinguish the node as end of word node. A simple structure to represent nodes of English alphabet can be as following,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trie node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">     TrieNode[] children[ALPHABET_SIZE];</span><br><span class="line">     <span class="comment">// isEndOfWord is true if the node represents end of a word</span></span><br><span class="line">     bool isEndOfWord;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="advantages"><a class="markdownIt-Anchor" href="#advantages"></a> Advantages</h2>
<p>A trie has a number of advantages over binary search trees. A trie can also be used to replace a hashtable, over which it has the following advantages:</p>
<ul>
<li><strong>Looking up data in a trie is faster in the worst case</strong>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span> time (where m is the length of a search string), compared to an imperfect hash table. An imperfect hash table can have key collisions. A key collision is the hash function mapping of different keys to the same position in a hash table. The worst-case lookup speed in an imperfect hash table is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> time, but far more typically is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span> time spent evaluating the hash.</li>
<li>Trie can <strong>add or remove keys</strong> in boundary worst cases <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>. If add or remove operation is pretty much more than query, Trie can be a good candidate when compared to HashMap.</li>
<li>We can easily print all words in <strong>alphabetical order</strong> which is not easily possible with hashing.</li>
<li>There are no collisions of different keys in a trie.</li>
</ul>
<p>Tries do have some drawbacks as well:</p>
<ul>
<li>Trie requires more <strong>space</strong> than hash table if data are small or some strings are very long.</li>
<li>Some keys, such as <strong>floating point numbers</strong>, can lead to long chains and prefixes that are not particularly meaningful. Nevertheless, a bitwise trie can handle standard IEEE single and double format floating point numbers.</li>
</ul>
<p>There are some ways that can reduce the drawbacks, but they all come at a cost.</p>
<ul>
<li>Use Bitwise Tries</li>
<li>Use compressing</li>
</ul>
<h2 id="query-5"><a class="markdownIt-Anchor" href="#query-5"></a> Query</h2>
<p>We only compare the characters and move down. The search can terminate due to end of string or lack of key in trie. In the former case, if the isEndofWord field of last node is true, then the key exists in trie. In the second case, the search terminates without examining all the characters of key, since the key is not present in trie.</p>
<p>Time complexity <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>, however the memory requirements of Trie is O(\text{ALPHABET_SIZE} * m * N) where N is number of keys in Trie.</p>
<p><img src="https://i.loli.net/2018/12/02/5c02db4b6044f.png" alt=""></p>
<h2 id="insertion"><a class="markdownIt-Anchor" href="#insertion"></a> Insertion</h2>
<p>Every character of input key is inserted as an individual Trie node. Note that the children is an array of pointers (or references) to next level trie nodes. The key character acts as an index into the array children. If the input key is new or an extension of existing key, we need to construct non-existing nodes of the key, and mark end of word for last node. If the input key is prefix of existing key in Trie, we simply mark the last node of key as end of word. The key length determines Trie depth.</p>
<p>Time complexity is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<p><img src="https://i.loli.net/2018/12/02/5c02db20e01c9.png" alt=""></p>
<h2 id="deletion"><a class="markdownIt-Anchor" href="#deletion"></a> Deletion</h2>
<p>When deleted, if given string is not at Trie, we do not need to modify the Trie. <code>delete</code> will delete all empty related branch and return an boolean indicates whether the sub branch need to be deleted. For each step, if we do not reach the end of word, we check if the corresponding branch exists path. If there is no path downward, it means given string does not exist. Otherwise, call <code>delete</code> on that branch and use the returned value to determine whether we need to delete the branch. If yes, mark the branch to null and return whether the current node’s children is empty. Otherwise we do not need to delete current branch.</p>
<p>When the current node that we are looking at is not the last node for key ‘k’, then</p>
<ol>
<li>We first make a recursive call to delete the node which is child of the <code>currentNode</code>.</li>
<li>We check if child node was deleted in step #1. If child node was not deleted then child node must be shared with some other key which implies this <code>currentNode</code> is also part of some other key and hence we do not delete <code>currentNode</code> and return <code>deletedSelf = false</code> to the parent node.</li>
<li>After step #1, if child node was deleted then we check if this <code>currentNode</code> can be deleted. We check that using two conditions: (a) If this node is marked as a leaf node then this node must be the last node corresponding to some other key and hence we return <code>deletedSelf = false</code> without deleting <code>currentNode</code>. (b) If this node has any more children then that means this node is part of some other key as well and hence return <code>deletedSelf = false</code> without deleting <code>currentNode</code>. © If both conditions (a) and (b) evaluate to false then we know that this node can be safely deleted. We return <code>deletedSelf</code> = true by marking <code>currentNode</code> as null</li>
</ol>
<p>Time complexity is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="traversal-2"><a class="markdownIt-Anchor" href="#traversal-2"></a> Traversal</h2>
<p>If current node is and <code>end</code> (<code>isEndOfWord</code> is true), we print all recorded prefix. Otherwise, we iterate through children, and call <code>print(node.children[i], s+(char)(i+'a'))</code> recursively.</p>
<p>Time complexity is $O()</p>
<h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isEndOfWord = <span class="keyword">false</span>;</span><br><span class="line">        Node[] children = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[i] != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node n = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (n.children[c-<span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n.children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            n = n.children[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n.isEndOfWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node n = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (n.children[c-<span class="string">'a'</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = n.children[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Node n = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.length();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (n.children[c-<span class="string">'a'</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = n.children[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delete(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Node node, String word, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node.isEndOfWord) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node.isEndOfWord = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> node.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (delete(node.children[c - <span class="string">'a'</span>], word, idx + <span class="number">1</span>)) &#123;</span><br><span class="line">            node.children[c - <span class="string">'a'</span>] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> !node.isEndOfWord &amp;&amp; node.isEmpty();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node node, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.isEndOfWord) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                print(node.children[i], s + (<span class="keyword">char</span>) (i + <span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h2>
<ul>
<li>Autocomplete
<ul>
<li>We are given a Trie with a set of strings stored in it. Now the user types in a prefix of his search query, we need to give him all recommendations to auto-complete his query based on the strings stored in the Trie. We assume that the Trie stores past searches by the users.</li>
<li>For example if the Trie store <code>{“abc”, “abcd”, “aa”, “abbbaba”}</code> and the User types in “ab” then he must be shown <code>{“abc”, “abcd”, “abbbaba”}</code>.</li>
<li>Solution:
<ul>
<li>First search for prefix given, it exists, print all recommendations using recursive print.</li>
</ul>
</li>
</ul>
</li>
<li>Spell Checker</li>
<li>IP Routing</li>
</ul>
<h1 id="red-black-tree"><a class="markdownIt-Anchor" href="#red-black-tree"></a> Red-Black Tree</h1>
<h2 id="concepts-2"><a class="markdownIt-Anchor" href="#concepts-2"></a> Concepts</h2>
<p>As you can see, the BST is not worth trusting. If the height is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, then the operations are also <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. Then we come up with a good idea: Red-Black Tree. Red-black trees are one of many search-tree schemes that are “<strong>balanced</strong>” in order to <strong>guarantee</strong> that basic dynamic-set operations take <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> time in the worst case.</p>
<p>A red-black tree is a <u>binary search tree</u> with one extra bit of storage per node: its <strong>color</strong>, which can be either RED or BLACK. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is <u>more than twice</u> as long as any other, so that the tree is approximately <strong>balanced</strong>. Because the shortest path is all nodes are black, the longest path is black and red nodes appear interleaving. So the shortest path is at most half of longest path according to property 4 and 5.</p>
<p>A red-black tree is a binary tree that satisﬁes the following <strong>red-black properties</strong>:</p>
<ol>
<li>Every node is either red or black.</li>
<li>The <strong>root</strong> is black.</li>
<li>Every <strong>leaf</strong> (NIL) is black.</li>
<li>If a node is red, then <strong>both its children are black.</strong> (black node can have black children)</li>
<li>For each node, all simple paths from the node to descendant leaves contain the <strong>same number</strong> of black nodes.</li>
</ol>
<p>As a matter of convenience in dealing with boundary conditions in red-black tree code, we use a single <strong>sentinel</strong> to represent NIL: <code>T.nil</code>. Its color is BLACK, other attributes are not important. All pointers to NIL are replaced by pointers to the sentinel <code>T.nil</code>.</p>
<p>We call the number of black nodes on any simple path from, but not including, a node x down to a leaf the <strong>black-height</strong> of the node, denoted <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">bh(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">b</span><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>.</p>
<p><img src="https://i.loli.net/2018/12/01/5c018ea9706fd.png" alt=""></p>
<h2 id="rotation"><a class="markdownIt-Anchor" href="#rotation"></a> Rotation</h2>
<p><code>Query</code> operations do not change the structure of RB Tree, thus they do not violate the red-black property. While, <code>Insert</code> and <code>Delete</code> operations may do. To restore these properties, we must change the colors of some of the nodes in the tree and also change the pointer structure.</p>
<p>We change the pointer structure through <strong>rotation</strong>, which is a local operation in a search tree that preserves the binary-search-tree property. There are two kinds of rotations: <strong>left rotations</strong> and <strong>right rotations</strong>. When we do a left rotation on a node x, we assume that its right child y is not <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">T.nil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span>. It makes y the new root of the subtree, with x as y’s left child and y’s left child as x’s right child.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/31/Tree_rotation_animation_250x250.gif" alt="mark"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)</span><br><span class="line">  y = x.right</span><br><span class="line">  x.right = y.left</span><br><span class="line">  if y.left != T.nil</span><br><span class="line">    y.left.p = x</span><br><span class="line">    y.p = x.p</span><br><span class="line">  if x.p == T.nil</span><br><span class="line">    T.root = y</span><br><span class="line">  elseif x == x.p.left</span><br><span class="line">    x.p.left = y</span><br><span class="line">  else x.p.right = y</span><br><span class="line">    y.left = x</span><br><span class="line">    x.p = y</span><br></pre></td></tr></table></figure>
<h2 id="comparison-with-avl-tree"><a class="markdownIt-Anchor" href="#comparison-with-avl-tree"></a> Comparison with AVL Tree</h2>
<p>The AVL trees are more balanced compared to Red-Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves many frequent insertions and deletions, then Red Black trees should be preferred. And if the insertions and deletions are less frequent and search is a more frequent operation, then AVL tree should be preferred over Red-Black Tree.</p>
<h1 id="interval-tree"><a class="markdownIt-Anchor" href="#interval-tree"></a> Interval Tree</h1>
<p>A <strong>closed interval</strong> is an ordered pair of real numbers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[t1,t2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">[</span><span class="mord mathit">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>, with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mn>1</mn><mo>≤</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \leq t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit">t</span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">t</span><span class="mord">2</span></span></span></span>. <strong>Open and half-open intervals</strong> omit both or one of the endpoints from the set, respectively. In this section, we shall assume that intervals are closed; extending the results to open and half-open intervals is conceptually straightforward.<br>
Intervals are convenient for representing events that each occupy a <strong>continuous period of time</strong>. We might, for example, wish to query a database of time intervals to ﬁnd out what events occurred during a given interval. The data structure in this section provides an efﬁcient means for maintaining such an interval database.<br>
We can represent an interval <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[t1,t2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">[</span><span class="mord mathit">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> as an object i, with attributes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i.low = t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">t</span><span class="mord">1</span></span></span></span>(the low endpoint) and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo>=</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">i.high = t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord">.</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">t</span><span class="mord">2</span></span></span></span> (the high endpoint). We say that intervals <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> overlap if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∩</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">i\cap i&#x27;=\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.833562em;vertical-align:-0.08167em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord amsrm">∅</span></span></span></span>, that is, if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo>≤</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i.low \leq i&#x27;.high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>l</mi><mi>e</mi><mi>q</mi><mi>i</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i&#x27;.low leq i.high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mord mathit">i</span><span class="mord">.</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span></span></span></span>. Any two intervals i and i’ satisfy the <strong>interval trichotomy</strong>; that is, exactly one of the following three properties holds:</p>
<ul>
<li>i and i’ overlap,</li>
<li>i is to the left of i’ (i.e., i.high &lt;i’.low),</li>
<li>i is to the right of i’ (i.e., i’.high &lt; i.low).</li>
</ul>
<p><strong>An interval tree</strong> is a red-black tree that maintains a dynamic set of elements, with each element x containing an interval x.int. Interval trees support the following operations:</p>
<ul>
<li><code>INTERVAL-INSERT(T,x)</code> adds the element x, whose int attribute is assumed to contain an interval, to the interval tree T.</li>
<li><code>INTERVAL-DELETE(T,x)</code> removes the element x from the interval tree T.</li>
<li><code>INTERVAL-SEARCH(T,i)</code> returns a pointer to an element x in the interval tree T such that x.int overlaps interval i, or a pointer to the sentinel T.nil if no such element is in the set.</li>
</ul>
<p>Node <strong>x</strong> in an interval tree contains an interval <code>x.int</code>, and the key of <strong>x</strong> is the low endpoint of interval, which is <code>x.int.low</code>. Thus, an inorder tree walk of the data structure lists the intervals in sorted order by low endpoint. Also, node <strong>x</strong> contains an attribute <code>max</code>, which is the maximum value of any interval endpoint (which is always should be node.high) stored in the subtree rooted at x. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>x</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x.max = max(x.int.high, x.left.max, x.right.max)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord">.</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mord">.</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">x</span><span class="mord">.</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord">.</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>.</p>
<p>And we need a new operation: <code>INTERVAL-SEARCH(T, i)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERTVAL-SEARCH(T, i)</span><br><span class="line">  x = T.root</span><br><span class="line">  while x != T.nil and i does not overlap with x.int</span><br><span class="line">    if x.left != T.nil and x.left.max &gt; i.low</span><br><span class="line">      x = x.left</span><br><span class="line">    else x = x.right</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure>
<h1 id="b-treeb-treeb-tree"><a class="markdownIt-Anchor" href="#b-treeb-treeb-tree"></a> B-Tree/B+ Tree/B* Tree</h1>
<h2 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B-Tree</h2>
<p>B-tree is a <strong>self-balancing tree</strong> data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree is a generalization of a binary search tree in that a node can have <strong>more than two children</strong>. The B-tree is well suited for storage systems that read and write relatively large blocks of data, such as discs. It is commonly used in <strong>databases</strong> and <strong>file systems</strong>.</p>
<p>In B-trees, <strong>internal</strong> (non-leaf) nodes can have a variable number of <strong>child nodes</strong> within some <strong>pre-defined range</strong>. When data is inserted or removed from a node, its number of child nodes changes. In order to maintain the pre-defined range, internal nodes may be <strong>joined</strong> or <strong>split</strong>. Because a range of child nodes is permitted, B-trees do not need re-balancing as frequently as other self-balancing search trees, but may waste some space, since nodes are not entirely full. The lower and upper bounds on the number of child nodes are typically fixed for a particular implementation. For example, in a 2-3 B-tree (often simply referred to as a 2-3 tree), each internal node may have only 2 or 3 child nodes.</p>
<p>Each internal node of a B-tree contains a number of keys. The <strong>keys</strong> act as separation values which divide its subtrees. For example, if an internal node has 3 child nodes (or subtrees) then it must have 2 keys: a1 and a2. All values in the leftmost subtree will be less than a1, all values in the middle subtree will be between a1 and a2, and all values in the rightmost subtree will be greater than a2.</p>
<p><img src="https://i.loli.net/2018/12/02/5c035bbb0388d.png" alt=""></p>
<p>Usually, the number of keys is chosen to vary between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">d</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">2d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord">2</span><span class="mord mathit">d</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">d</span></span></span></span> is the minimum number of keys, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">d</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span> is the minimum <a href="https://en.wikipedia.org/wiki/Outdegree#Indegree_and_outdegree" target="_blank" rel="noopener">degree</a> or <a href="https://en.wikipedia.org/wiki/Branching_factor" target="_blank" rel="noopener">branching factor</a> of the tree.</p>
<p>A B-tree is kept <strong>balanced</strong> by requiring that <strong>all leaf nodes be at the same depth</strong>. This depth will increase slowly as elements are added to the tree, but an increase in the overall depth is infrequent.</p>
<p>Height <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">h</span></span></span></span> is at most <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>≤</mo><mo>⌊</mo><msub><mi>log</mi><mo>⁡</mo><mi>d</mi></msub><mo>(</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>)</mo><mo>⌋</mo></mrow><annotation encoding="application/x-tex">h\leq \lfloor \log_d (\frac{n+1}{2})\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base"><span class="mord mathit">h</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999993em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewbox="0 0 400000 200" preserveaspectratio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"/></svg></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span>.</p>
<h3 id="advantages-of-b-tree-usage-for-databases"><a class="markdownIt-Anchor" href="#advantages-of-b-tree-usage-for-databases"></a> Advantages of B-tree usage for databases</h3>
<p>B-trees have substantial <strong>advantages</strong> over alternative implementations when the time to access the <strong>data of a node</strong> greatly exceeds the time spent processing that data, because then the cost of accessing the node may be amortized over multiple operations within the node. This usually occurs when the node data are in secondary storage such as disk drives. By maximizing the number of keys within each internal node, the height of the tree decreases and the number of expensive node accesses is reduced. In addition, rebalancing of the tree occurs less often. The maximum number of child nodes depends on the information that must be stored for each child node and the size of a full disk block or an analogous size in secondary storage. While 2-3 B-trees are easier to explain, practical B-trees using secondary storage need a large number of child nodes to improve performance.</p>
<p>The B-tree uses all of the ideas described above. In particular, a B-tree:</p>
<ul>
<li>keeps keys in sorted order for sequential traversing</li>
<li>uses a hierarchical index to minimize the number of disk reads</li>
<li>uses partially full blocks to speed insertions and deletions</li>
<li>keeps the index balanced with a recursive algorithm</li>
</ul>
<p>In addition, a B-tree minimizes waste by making sure the interior nodes are at least half full.</p>
<h2 id="b-tree-2"><a class="markdownIt-Anchor" href="#b-tree-2"></a> B+ Tree</h2>
<p>A B+ tree can be viewed as a B-tree in which each node contains <strong>only keys</strong> (not key–value pairs), and to which an additional level is added at the bottom with linked leaves. Because B+ trees don’t have data associated with interior nodes, <strong>more keys</strong> can fit on a page of memory. The leaf nodes of B+ trees are linked, so doing a <strong>full scan</strong> of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.</p>
<p><img src="https://i.loli.net/2018/12/02/5c035ff5c1084.png" alt=""></p>
<h2 id="why-b-tree-is-more-suitable-than-b-tree"><a class="markdownIt-Anchor" href="#why-b-tree-is-more-suitable-than-b-tree"></a> Why B+ Tree is more suitable than B-Tree</h2>
<p>一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mi>d</mi></msub><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)=O(\log_dN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">h</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999993em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mo>⌊</mo><mfrac><mrow><mtext>pagesize</mtext></mrow><mrow><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>)</mo><mo>)</mo></mrow></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">d_{max}=\lfloor \frac{\text{pagesize}}{(keysize+datasize+pointsize))}\rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.3448600000000002em;"></span><span class="strut bottom" style="height:2.28086em;vertical-align:-0.936em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3448600000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">d</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewbox="0 0 400000 200" preserveaspectratio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"/></svg></span></span><span style="top:-3.6770000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">pagesize</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></span></p>
<p>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<h1 id="union-find"><a class="markdownIt-Anchor" href="#union-find"></a> Union Find</h1>
<p>Union Find is a pretty straightforward algorithm that ogranize array to a tree-like structure. It can support <code>union</code> and <code>find</code> operation. <code>union</code> merges two components into one component, and <code>find</code> can check whether two elements are in the same component.</p>
<blockquote>
<p>see reference <a href="https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf" target="_blank" rel="noopener">here</a></p>
</blockquote>
<p><img src="https://i.loli.net/2018/12/04/5c05a8ecd52df.png" alt=""></p>
<p><strong>Data Structure:</strong></p>
<p>an array record what the parent idx of current node: <code>parents[N]</code>. We can <code>find</code> by searching root of two nodes by check its parent recursively. And <code>union</code> two components by assigning one root’s parent to the other root’s parent.</p>
<p>There are two important <strong>optimization</strong>:</p>
<ol>
<li>
<p><strong>Path Compression</strong>: When searching for root, we can assign every searched node’s parent to root node. Or, we can just set its parent to its grandparent, and move to its current parent and continue to search.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// first version, every node assgined to root node.</span><br><span class="line">ROOT(x)</span><br><span class="line">  if x != parents[x]:</span><br><span class="line">    parents[x] = ROOT(parents[x])</span><br><span class="line">  return x</span><br><span class="line"></span><br><span class="line">// second version, easier and faster, but not as flat as previous one.</span><br><span class="line">ROOT(x)</span><br><span class="line">  while x != parents[x]:</span><br><span class="line">    parents[x] = parents[parents[x]]</span><br><span class="line">    x = parents[x]</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Weighting</strong>. And extra array <code>sizes[N]</code> stores how many nodes the component have. Balance by linking small tree below large one, to avoid <strong>tall trees</strong>.</p>
</li>
</ol>
<h2 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        sizes = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            sizes[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]];</span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pid = root(p);</span><br><span class="line">        <span class="keyword">int</span> qid = root(q);</span><br><span class="line">        <span class="keyword">if</span> (sizes[pid] &lt; sizes[qid]) &#123;</span><br><span class="line">            parents[pid] = qid;</span><br><span class="line">            sizes[qid] += sizes[pid];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[qid] = pid;</span><br><span class="line">            sizes[pid] += sizes[qid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p) == root(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="visualization"><a class="markdownIt-Anchor" href="#visualization"></a> Visualization</h1>
<p>Website: <a href="https://visualgo.net/bn/bst" target="_blank" rel="noopener">https://visualgo.net/bn/bst</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/notes/" rel="tag"># notes</a>
          
            <a href="/tags/tree/" rel="tag"># tree</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/Leetcode-Sort/" rel="next" title="Leetcode: Sort">
                <i class="fa fa-chevron-left"></i> Leetcode: Sort
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/Algorithm-04-Graph/" rel="prev" title="Algorithm(04): Graph">
                Algorithm(04): Graph <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">黄泽强（Zeqiang Huang)</p>
              <p class="site-description motion-element" itemprop="description">笔记/科研</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hzqjyyx" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          
          <div id="toc-div" class="post-toc" style="display:block">
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#basic-idea"><span class="nav-number">1.</span> <span class="nav-text"> Basic Idea</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#concepts"><span class="nav-number">2.</span> <span class="nav-text"> Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#free-tree"><span class="nav-number">2.1.</span> <span class="nav-text"> Free Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rooted-and-ordered-tree"><span class="nav-number">2.2.</span> <span class="nav-text"> Rooted and ordered tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#binary-tree"><span class="nav-number">3.</span> <span class="nav-text"> Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#left-child-right-sibling"><span class="nav-number">3.1.</span> <span class="nav-text"> Left-child right-sibling</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#traversal"><span class="nav-number">4.</span> <span class="nav-text"> Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recursively"><span class="nav-number">4.1.</span> <span class="nav-text"> Recursively</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative"><span class="nav-number">4.2.</span> <span class="nav-text"> Iterative</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pre-order-traversal"><span class="nav-number">4.2.1.</span> <span class="nav-text"> Pre-order Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-order-traversal"><span class="nav-number">4.2.2.</span> <span class="nav-text"> In-order Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#post-order-traversal"><span class="nav-number">4.2.3.</span> <span class="nav-text"> Post-order Traversal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#binary-search-tree"><span class="nav-number">5.</span> <span class="nav-text"> Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#explanation"><span class="nav-number">5.1.</span> <span class="nav-text"> Explanation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#suitable-situation"><span class="nav-number">5.2.</span> <span class="nav-text"> Suitable Situation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#query"><span class="nav-number">5.3.</span> <span class="nav-text"> Query</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#search"><span class="nav-number">5.3.1.</span> <span class="nav-text"> Search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-and-maximum"><span class="nav-number">5.3.2.</span> <span class="nav-text"> Minimum and Maximum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#successor-and-predecessor"><span class="nav-number">5.3.3.</span> <span class="nav-text"> Successor and Predecessor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insert-and-delete"><span class="nav-number">5.4.</span> <span class="nav-text"> Insert and Delete</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-number">5.4.1.</span> <span class="nav-text"> Insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete"><span class="nav-number">5.4.2.</span> <span class="nav-text"> Delete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#random-build-binary-search-tree"><span class="nav-number">5.5.</span> <span class="nav-text"> Random Build Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-code"><span class="nav-number">5.6.</span> <span class="nav-text"> Java Code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#non-distinct-keys"><span class="nav-number">5.7.</span> <span class="nav-text"> Non-distinct keys</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#segment-tree"><span class="nav-number">6.</span> <span class="nav-text"> Segment Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive"><span class="nav-number">6.1.</span> <span class="nav-text"> Recursive</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#build-segment-tree"><span class="nav-number">6.1.1.</span> <span class="nav-text"> Build Segment Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update"><span class="nav-number">6.1.2.</span> <span class="nav-text"> Update</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#query-2"><span class="nav-number">6.1.3.</span> <span class="nav-text"> Query</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative-2"><span class="nav-number">6.2.</span> <span class="nav-text"> Iterative</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#build-segment-tree-2"><span class="nav-number">6.2.1.</span> <span class="nav-text"> Build Segment Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-2"><span class="nav-number">6.2.2.</span> <span class="nav-text"> Update</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#query-3"><span class="nav-number">6.2.3.</span> <span class="nav-text"> Query</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#binary-indexed-tree"><span class="nav-number">7.</span> <span class="nav-text"> Binary Indexed Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#query-4"><span class="nav-number">7.1.</span> <span class="nav-text"> Query</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update-3"><span class="nav-number">7.2.</span> <span class="nav-text"> Update</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#trie"><span class="nav-number">8.</span> <span class="nav-text"> Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#advantages"><span class="nav-number">8.1.</span> <span class="nav-text"> Advantages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#query-5"><span class="nav-number">8.2.</span> <span class="nav-text"> Query</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insertion"><span class="nav-number">8.3.</span> <span class="nav-text"> Insertion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deletion"><span class="nav-number">8.4.</span> <span class="nav-text"> Deletion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#traversal-2"><span class="nav-number">8.5.</span> <span class="nav-text"> Traversal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#code"><span class="nav-number">8.6.</span> <span class="nav-text"> Code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#application"><span class="nav-number">8.7.</span> <span class="nav-text"> Application</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#red-black-tree"><span class="nav-number">9.</span> <span class="nav-text"> Red-Black Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#concepts-2"><span class="nav-number">9.1.</span> <span class="nav-text"> Concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rotation"><span class="nav-number">9.2.</span> <span class="nav-text"> Rotation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#comparison-with-avl-tree"><span class="nav-number">9.3.</span> <span class="nav-text"> Comparison with AVL Tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#interval-tree"><span class="nav-number">10.</span> <span class="nav-text"> Interval Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-treeb-treeb-tree"><span class="nav-number">11.</span> <span class="nav-text"> B-Tree/B+ Tree/B* Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#b-tree"><span class="nav-number">11.1.</span> <span class="nav-text"> B-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#advantages-of-b-tree-usage-for-databases"><span class="nav-number">11.1.1.</span> <span class="nav-text"> Advantages of B-tree usage for databases</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b-tree-2"><span class="nav-number">11.2.</span> <span class="nav-text"> B+ Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#why-b-tree-is-more-suitable-than-b-tree"><span class="nav-number">11.3.</span> <span class="nav-text"> Why B+ Tree is more suitable than B-Tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#union-find"><span class="nav-number">12.</span> <span class="nav-text"> Union Find</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#code-2"><span class="nav-number">12.1.</span> <span class="nav-text"> Code</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#visualization"><span class="nav-number">13.</span> <span class="nav-text"> Visualization</span></a></li></ol></div>
            
          </div>

          
          
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄泽强（Zeqiang Huang)</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="Symbols count total"></span>
  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  

  
    <script id="dsq-count-scr" src="https://hzqjyyx.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://hzqjyyx.github.io/2018/06/Algorithm-03-Tree/';
        this.page.identifier = '2018/06/Algorithm-03-Tree/';
        this.page.title = 'Algorithm(03): Tree';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://hzqjyyx.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  

  
    
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" type="text/css">

   
  


  
  

  

  

  

  

</body>
</html>
